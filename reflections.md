Reflections
===========

<!--
This file generated by the build script at ./Build.hs from the files in
./reflections.  If you want to edit this, edit those instead!
-->

Table of Contents
-----------------

* [Day 1](#day-1)
* [Day 2](#day-2)
* [Day 3](#day-3) *(no reflection yet)*

Day 1
------

<!--
This section is generated and compiled by the build script at ./Build.hs from
the file `./reflections/day01.md`.  If you want to edit this, edit
that file instead!
-->

*[Prompt][d01p]* / *[Code][d01g]*

[d01p]: https://adventofcode.com/2021/day/1
[d01g]: https://github.com/egnwd/advent/blob/2021/src/AOC/Challenge/Day01.hs

Reading a list of ints always seems to be early on, we can do that easily with:

```haskell
parser = map read . lines
```

Then for part 1 we need to get the differences, which can be achieved by dropping the head of the
list then subtracting the two lists element-wise:

```haskell
differences x = zipWith subtract x (tail x)
```

_N.B. `subtract` is just `-` with the arguments flipped, useful for partial application._

and then to get the answer we need only the increases we just filter for where we got a postitive result:

```haskell
part1 = length . filter (>0) . differences
```

Yay! 1 star!

For part 2 we can reuse the differences logic from part 1, we just need to construct a new input list using the windows.
The easiest way to do this given the window is only length 3 is use the version of `zipWith` that takes 3 lists, this time with addition.

```haskell
summedSlidingWindows x = zipWith3 (\a b c -> a + b + c) x (drop 1 x) (drop 2 x)
```

Then to solve we just use part 1.

```haskell
part2 = part1 . summedSlidingWindows
```

Day 1 complete!


### Day 1 Benchmarks

```
>> Day 01a
benchmarking...
time                 47.27 μs   (46.45 μs .. 48.43 μs)
                     0.994 R²   (0.990 R² .. 0.997 R²)
mean                 47.09 μs   (45.79 μs .. 48.64 μs)
std dev              4.412 μs   (3.534 μs .. 5.703 μs)
variance introduced by outliers: 82% (severely inflated)

* parsing and formatting times excluded

>> Day 01b
benchmarking...
time                 208.5 μs   (202.4 μs .. 214.6 μs)
                     0.994 R²   (0.990 R² .. 0.997 R²)
mean                 210.7 μs   (206.9 μs .. 216.4 μs)
std dev              15.33 μs   (10.99 μs .. 20.72 μs)
variance introduced by outliers: 67% (severely inflated)

* parsing and formatting times excluded
```



Day 2
------

<!--
This section is generated and compiled by the build script at ./Build.hs from
the file `./reflections/day02.md`.  If you want to edit this, edit
that file instead!
-->

*[Prompt][d02p]* / *[Code][d02g]*

[d02p]: https://adventofcode.com/2021/day/2
[d02g]: https://github.com/egnwd/advent/blob/2021/src/AOC/Challenge/Day02.hs

Moving around a 2D map, another AoC classic challenge.

My initial solution used recursion and word splitting for the solution,
the second used State, and that too was more difficult to understand, and felt more imperative.

The version here uses Monoids to combine the values (part a ended up similar to my first fold attempt).

To parse we can read many `Sum`mable `Points` and have that as our instruction set.
The parser combinators make this quite nice to do:

```haskell
parser = do
  dir <- pTok $
        (Sum . flip V2 0     <$ "forward")
    <|> (Sum . V2 0 . negate <$ "up")
    <|> (Sum . V2 0          <$ "down")
  dir <$> pDecimal
```

Then to solve part 1 we just need to combine the instructions.
I used the `V2` type from `Linear.V2` to represent points as they are 2D vectors with the added bonus of
being able to easily to component-wise addition of vectors.

```haskell
solve = product . getSum . mconcat
```

After the submarine's epic journey, we get 1 star!

For part two, I wrote a new type `Submarine` with a location and aim.

```haskell
data Submarine = Sub { loc :: Point, aim :: Int }
```

this time to combine we must implement `Monoid`, and first Semigroup.

```haskell
instance Semigroup Submarine where
    (Sub v a) <> (Sub (V2 x' y') a') = Sub (v + V2 x' (y' + x' * a)) (a + a')

instance Monoid Submarine where
    mempty = Sub (pure 0) 0
    mconcat = foldl (<>) mempty
```

`(<>)` combines two commands, adding the forward components `x+x'`,
updates the depth taking into account the previous aim and the forward distance
`y + y' + x' * a` (for the `up` & `down` commands `x'` & `y'` are `0` so that term cancels),
and finally the aim is updated (for `forward` this is `0` so is also a noop).

Then to combine we do similar to part 1:
```haskell
solve = product . loc . mconcat
```

where `loc` gets the vector from the `Submarine` akin to `getSum` getting the vector from `Sum`.

Submarine successfully piloted!


### Day 2 Benchmarks

```
>> Day 02a
benchmarking...
time                 3.811 ms   (3.759 ms .. 3.889 ms)
                     0.997 R²   (0.995 R² .. 0.999 R²)
mean                 3.781 ms   (3.721 ms .. 3.821 ms)
std dev              164.2 μs   (126.4 μs .. 240.8 μs)
variance introduced by outliers: 25% (moderately inflated)

>> Day 02b
benchmarking...
time                 2.332 ms   (2.310 ms .. 2.357 ms)
                     0.999 R²   (0.999 R² .. 1.000 R²)
mean                 2.345 ms   (2.330 ms .. 2.363 ms)
std dev              54.61 μs   (42.35 μs .. 69.57 μs)
variance introduced by outliers: 10% (moderately inflated)
```



Day 3
------

<!--
This section is generated and compiled by the build script at ./Build.hs from
the file `./reflections/day03.md`.  If you want to edit this, edit
that file instead!
-->

*[Prompt][d03p]* / *[Code][d03g]*

[d03p]: https://adventofcode.com/2021/day/3
[d03g]: https://github.com/egnwd/advent/blob/2021/src/AOC/Challenge/Day03.hs

*Reflection not yet written -- please check back later!*

### Day 3 Benchmarks

```
>> Day 03a
benchmarking...
time                 2.608 ms   (2.560 ms .. 2.668 ms)
                     0.997 R²   (0.996 R² .. 0.998 R²)
mean                 2.565 ms   (2.531 ms .. 2.593 ms)
std dev              111.2 μs   (82.98 μs .. 138.1 μs)
variance introduced by outliers: 28% (moderately inflated)

* parsing and formatting times excluded

>> Day 03b
benchmarking...
time                 502.3 μs   (499.8 μs .. 505.3 μs)
                     1.000 R²   (1.000 R² .. 1.000 R²)
mean                 508.0 μs   (505.6 μs .. 511.4 μs)
std dev              10.85 μs   (7.919 μs .. 18.69 μs)
variance introduced by outliers: 12% (moderately inflated)

* parsing and formatting times excluded
```

