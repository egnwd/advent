Reflections
===========

<!--
This file generated by the build script at ./Build.hs from the files in
./reflections.  If you want to edit this, edit those instead!
-->

Table of Contents
-----------------

* [Day 1](#day-1)
* [Day 2](#day-2)
* [Day 3](#day-3)
* [Day 4](#day-4)
* [Day 5](#day-5) *(no reflection yet)*

Day 1
------

<!--
This section is generated and compiled by the build script at ./Build.hs from
the file `./reflections/day01.md`.  If you want to edit this, edit
that file instead!
-->

*[Prompt][d01p]* / *[Code][d01g]*

[d01p]: https://adventofcode.com/2022/day/1
[d01g]: https://github.com/egnwd/advent/blob/2022/src/AOC/Challenge/Day01.hs

My prewritten parser almost worked... just needed to install the split library...

But in any case parsing was relatively straight forward.
We simply need to split into the elf groups and the split the individual lines and read the numbers.

```haskell
parse :: String -> [[Int]]
parse = map (map read) . map lines . splitOn "\n\n"
```

To find the top one for part a I originally went for the following `foldMap` approach using the useful [`Max` Semigroup](https://hackage.haskell.org/package/base-4.17.0.0/docs/Data-Semigroup.html#t:Max)

```haskell
solve :: [[Int]] -> Int
solve = getMax . foldMap (Max . sum)
```

Which, yay!, works but when we get to part 2 we can make more generic and reuse the part 2 implementation.

```haskell
solve :: [[Int]] -> Int
solve = sum . take 3 . reverse . sort . map sum
```

This solution does away with `Max` in favour of just sorting the summed list.

We can then pass in how many elves are contributing snacks:

```haskell
solve :: Int -> [[Int]] -> Int
solve n = sum . take n . reverse . sort . map sum
```

and tada! We've started our long journey[^1] into the jungle!

[^1]: _journey_ would be a great codename for a project


### Day 1 Benchmarks

```
>> Day 01a
benchmarking...
time                 24.49 μs   (24.43 μs .. 24.58 μs)
                     1.000 R²   (1.000 R² .. 1.000 R²)
mean                 24.53 μs   (24.50 μs .. 24.59 μs)
std dev              158.0 ns   (127.0 ns .. 192.4 ns)

* parsing and formatting times excluded

>> Day 01b
benchmarking...
time                 26.14 μs   (25.61 μs .. 27.30 μs)
                     0.993 R²   (0.982 R² .. 1.000 R²)
mean                 25.94 μs   (25.72 μs .. 27.12 μs)
std dev              1.304 μs   (239.6 ns .. 3.152 μs)
variance introduced by outliers: 58% (severely inflated)

* parsing and formatting times excluded
```



Day 2
------

<!--
This section is generated and compiled by the build script at ./Build.hs from
the file `./reflections/day02.md`.  If you want to edit this, edit
that file instead!
-->

*[Prompt][d02p]* / *[Code][d02g]*

[d02p]: https://adventofcode.com/2022/day/2
[d02g]: https://github.com/egnwd/advent/blob/2022/src/AOC/Challenge/Day02.hs

Hmm... Well I messed up.

I had the solution fairly quickly by hard coding the mappings suggested and lots of lookups...
and then decided the intended solution was to find the *maximum* score given any strategy...

which does have a nice little form

```haskell
strategies = map (zip "ABC") (permutations "XYZ")
```

and then you simply need to find the maximum from applying all the strategies.


But that's wrong, so let's simplify.

First we can set up a parser, using the default lookup:

```haskell
parseGame = do
    opp <- Rock <$ "A" <|> Paper <$ "B" <|> Scissors <$ "C"
    pSpace
    you <- Rock <$ "X" <|> Paper <$ "Y" <|> Scissors <$ "Z"
    return (opp, you)
```

and then we can score a game given some rules on the winner:

```haskell
Paper    `play` Rock     = Win
Rock     `play` Scissors = Win
Scissors `play` Paper    = Win
a        `play` b
  | a == b = Draw
  | otherwise = Lose
```

I wasn't hugely happy with this, I tried an implementation with `Ord` and another with `Map`
but this was still the simplest, and it's a total function as we've parsed the inputs into nice types.

Then given the scoring functions set out in the puzzle:

```haskell
score you out = scoreRPS you + scoreOutcome out

scoreRPS = \case
    Rock     -> 1
    Paper    -> 2
    Scissors -> 3

scoreOutcome = \case
    Win  -> 6
    Draw -> 3
    Lose -> 0
```

we can score a game simply using ``\opp you -> score you (you `play` opp)``.

Finally.

Then for part two, much the same we just need a different lookup and different parser.

```haskell
parseStrategy = do
    opp <- Rock <$ "A" <|> Paper <$ "B" <|> Scissors <$ "C"
    pSpace
    out <- Lose <$ "X" <|> Draw <$ "Y" <|> Win <$ "Z"
    return (opp, out)

whatToPlay a        Draw = a
whatToPlay Paper    Win  = Scissors
whatToPlay Rock     Win  = Paper
whatToPlay Scissors Win  = Rock
whatToPlay Paper    Lose = Rock
whatToPlay Rock     Lose = Scissors
whatToPlay Scissors Lose = Paper
```

again, I'm not a fan of huge lookups but there we go.

putting together what we already have gives us ``\opp out -> score (whatToPlay opp out) out``.

Two stars, but not the most satisfying.


### Day 2 Benchmarks

```
>> Day 02a
benchmarking...
time                 5.104 ms   (5.050 ms .. 5.174 ms)
                     0.999 R²   (0.998 R² .. 0.999 R²)
mean                 5.089 ms   (5.033 ms .. 5.130 ms)
std dev              142.0 μs   (113.0 μs .. 190.2 μs)
variance introduced by outliers: 11% (moderately inflated)

>> Day 02b
benchmarking...
time                 2.760 ms   (2.734 ms .. 2.813 ms)
                     0.987 R²   (0.962 R² .. 0.999 R²)
mean                 2.812 ms   (2.771 ms .. 3.004 ms)
std dev              237.1 μs   (88.73 μs .. 499.2 μs)
variance introduced by outliers: 57% (severely inflated)
```



Day 3
------

<!--
This section is generated and compiled by the build script at ./Build.hs from
the file `./reflections/day03.md`.  If you want to edit this, edit
that file instead!
-->

*[Prompt][d03p]* / *[Code][d03g]*

[d03p]: https://adventofcode.com/2022/day/3
[d03g]: https://github.com/egnwd/advent/blob/2022/src/AOC/Challenge/Day03.hs

Interesting, today was a day where I used a different parser for part 1 and 2.

For part 1 we can split it into lines, chop each in half and turn them into sets:

```haskell
splitHalf :: String -> (Set Char, Set Char)
splitHalf s = let h = length s `div` 2
                  (l, r) splitAt h s
               in (S.fromList l, S.fromList r)

parsea :: String -> [(Set Char, Set Char)]
parsea = map splitHalf . lines
```

Then solving is a simple map and score function:

```haskell
priority :: Char -> Int
priority c
    | isUpper c = 27 + (((subtract . ord) 'A') . ord) c
    | otherwise = 1  + (((subtract . ord) 'a') . ord) c

matchingItem :: (Set Char, Set Char) -> Char
matchingItem (r1, r2) = head . S.toList $ S.intersection r1 r2

solvea = sum . map (priority . matchingItem) . parsea
```

Yay! Rucksack's organized

Part 2 was similar, but we don't need to split in half, we need batches of 3.

```haskell
parseb :: String -> [[Set Char]]
parseb = chunksOf 3 . lines
```

solving is then just repeatedly intersecting the batches:

```haskell
findGroupBadge :: [Set Char] -> Char
findGroupBadge = head . S.toList . foldl1' S.intersection

solveb = sum . map (priority . findGroupBadge) . parseb
```

One thing with the above solution (which is very close to my initial attempt)
is that it doesn't do any error handling.

What if splitting a rucksack in half leaves an empty section?
What if there is a item we don't expect, `&` perhaps?
What if we have no matching item after all the intersections?

For my final implementation I added in some error handling which was good fun,
though for these sorts of problems it's not required as the inputs are well formed.

For starters, Items can only have priorities 1-52,
so I decided to use the `Finite` type which lets you restrict the number of inhabitants of the type.

```haskell
type Item = Finite 53
```

the 53 allows for the `0` inhabitant, but you'll see why I think that's fine in a second.

Now to create the `Item` type I can use

```haskell
priority :: Char -> Maybe Item
priority c
    | isUpper c = packFinite . fromIntegral $ 27 + (((subtract . ord) 'A') . ord) c
    | otherwise = packFinite . fromIntegral $ 1  + (((subtract . ord) 'a') . ord) c
```

You'll see the type change to reflect the fact this operation can fail.
I think 53 is fine as in both branches we add at least `1` so the `0` can never appear and we can sort of sweep it under the rug.

Next I dealt with the fact intersections can leave you with an empty set.

Rucksacks can now be defined as non empty sets of characters:

```haskell
type Rucksack = NESet Char
```

Defining the intersections now needs a little more work to deal with this error case:

```haskell
intersections :: Ord a => [NESet a] -> Maybe (Set a)
intersections = foldl1May S.intersection . fmap NES.toSet
```

First, turn the non empty sets into normal sets, run the intersection using a `foldl1May`...

`foldl1May` is a left fold that assumes there is at least 1 element in the list.
Normal `foldl1` will error if you don't:

```ghci
λ> foldl1 (+) [] :: Int
*** Exception: Prelude.foldl1: empty list
```

where as `foldl1May` returns `Nothing`:

```ghci
λ> foldl1May (+) [] :: Maybe Int
Nothing
```

This now returns a set, as all of the elements could have been removed in the intersections.

Finally, to get out a single element from the set could be risky if they were all removed.

For this we can use `Lens`es, which has a nice function `preview` that allows you to grab the first matching element if one exists of a folded or traversable.
Here we have sets and we don't want any special filters, so plain `preview folded` should do.


For how all this is strung together check out the code, linked from the top of this reflection.


### Day 3 Benchmarks

```
>> Day 03a
benchmarking...
time                 255.3 μs   (254.4 μs .. 256.1 μs)
                     1.000 R²   (1.000 R² .. 1.000 R²)
mean                 254.9 μs   (254.5 μs .. 255.4 μs)
std dev              1.572 μs   (1.232 μs .. 2.181 μs)

* parsing and formatting times excluded

>> Day 03b
benchmarking...
time                 292.2 μs   (291.6 μs .. 292.9 μs)
                     1.000 R²   (1.000 R² .. 1.000 R²)
mean                 291.9 μs   (291.4 μs .. 292.6 μs)
std dev              2.047 μs   (1.555 μs .. 2.879 μs)

* parsing and formatting times excluded
```



Day 4
------

<!--
This section is generated and compiled by the build script at ./Build.hs from
the file `./reflections/day04.md`.  If you want to edit this, edit
that file instead!
-->

*[Prompt][d04p]* / *[Code][d04g]*

[d04p]: https://adventofcode.com/2022/day/4
[d04g]: https://github.com/egnwd/advent/blob/2022/src/AOC/Challenge/Day04.hs

Today was a nice set theory question, and for that we need to parse some sets of jobs:

```haskell
parseElfPairJobs :: String -> (ElfJobs, ElfJobs)
parseElfPairJobs s =
    let [a,b,c,d] <- map read . splitOneOf ",-" $ s
        l = IS.fromList . Ix.range $ (a,b)
        r = IS.fromList . Ix.range $ (c,d)
     in (l,r)
```

We can get a set for each of the ranges of section ids in the elves' task lists.

[Data.Ix has a really helpful function `range`](https://hackage.haskell.org/package/base-4.17.0.0/docs/Data-Ix.html#v:range) for this sort of thing.

Then for part 1 we need to see if either is a subset of the other:

```haskell
day04a = length . filter (\(l,r) -> l `isSubsetOf` r || r `isSubsetOf` l) . map parseElfPairJobs . lines
```

Yay! One star! and for part two we just need to know if there is an intersection of the two:

```haskell
day04b = length . filter (\(l,r) -> not . null . intersection l r) . map parseElfPairJobs . lines
```

with that, the ship is spick & span.


### Day 4 Benchmarks

```
>> Day 04a
benchmarking...
time                 25.35 μs   (25.25 μs .. 25.46 μs)
                     1.000 R²   (1.000 R² .. 1.000 R²)
mean                 25.33 μs   (25.25 μs .. 25.42 μs)
std dev              307.2 ns   (236.3 ns .. 423.7 ns)

* parsing and formatting times excluded

>> Day 04b
benchmarking...
time                 22.30 μs   (22.24 μs .. 22.35 μs)
                     1.000 R²   (1.000 R² .. 1.000 R²)
mean                 22.29 μs   (22.25 μs .. 22.33 μs)
std dev              124.7 ns   (92.67 ns .. 166.1 ns)

* parsing and formatting times excluded
```



Day 5
------

<!--
This section is generated and compiled by the build script at ./Build.hs from
the file `./reflections/day05.md`.  If you want to edit this, edit
that file instead!
-->

*[Prompt][d05p]* / *[Code][d05g]*

[d05p]: https://adventofcode.com/2022/day/5
[d05g]: https://github.com/egnwd/advent/blob/2022/src/AOC/Challenge/Day05.hs

*Reflection not yet written -- please check back later!*

### Day 5 Benchmarks

```
>> Day 05a
benchmarking...
time                 7.637 ms   (7.534 ms .. 7.733 ms)
                     0.999 R²   (0.998 R² .. 0.999 R²)
mean                 7.589 ms   (7.495 ms .. 7.673 ms)
std dev              254.3 μs   (190.7 μs .. 355.3 μs)
variance introduced by outliers: 14% (moderately inflated)

>> Day 05b
benchmarking...
time                 4.078 ms   (4.055 ms .. 4.106 ms)
                     1.000 R²   (0.999 R² .. 1.000 R²)
mean                 4.080 ms   (4.061 ms .. 4.098 ms)
std dev              52.88 μs   (45.22 μs .. 67.02 μs)
```

