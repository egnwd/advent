Reflections
===========

<!--
This file generated by the build script at ./Build.hs from the files in
./reflections.  If you want to edit this, edit those instead!
-->

Table of Contents
-----------------

* [Day 1](#day-1)
* [Day 2](#day-2)
* [Day 3](#day-3)
* [Day 4](#day-4)
* [Day 5](#day-5)
* [Day 6](#day-6)

Day 1
------

<!--
This section is generated and compiled by the build script at ./Build.hs from
the file `./reflections/day01.md`.  If you want to edit this, edit
that file instead!
-->

*[Prompt][d01p]* / *[Code][d01g]*

[d01p]: https://adventofcode.com/2022/day/1
[d01g]: https://github.com/egnwd/advent/blob/2022/src/AOC/Challenge/Day01.hs

My prewritten parser almost worked... just needed to install the split library...

But in any case parsing was relatively straight forward.
We simply need to split into the elf groups and the split the individual lines and read the numbers.

```haskell
parse :: String -> [[Int]]
parse = map (map read) . map lines . splitOn "\n\n"
```

To find the top one for part a I originally went for the following `foldMap` approach using the useful [`Max` Semigroup](https://hackage.haskell.org/package/base-4.17.0.0/docs/Data-Semigroup.html#t:Max)

```haskell
solve :: [[Int]] -> Int
solve = getMax . foldMap (Max . sum)
```

Which, yay!, works but when we get to part 2 we can make more generic and reuse the part 2 implementation.

```haskell
solve :: [[Int]] -> Int
solve = sum . take 3 . reverse . sort . map sum
```

This solution does away with `Max` in favour of just sorting the summed list.

We can then pass in how many elves are contributing snacks:

```haskell
solve :: Int -> [[Int]] -> Int
solve n = sum . take n . reverse . sort . map sum
```

and tada! We've started our long journey[^1] into the jungle!

[^1]: _journey_ would be a great codename for a project


### Day 1 Benchmarks

```
>> Day 01a
benchmarking...
time                 24.49 Î¼s   (24.43 Î¼s .. 24.58 Î¼s)
                     1.000 RÂ²   (1.000 RÂ² .. 1.000 RÂ²)
mean                 24.53 Î¼s   (24.50 Î¼s .. 24.59 Î¼s)
std dev              158.0 ns   (127.0 ns .. 192.4 ns)

* parsing and formatting times excluded

>> Day 01b
benchmarking...
time                 26.14 Î¼s   (25.61 Î¼s .. 27.30 Î¼s)
                     0.993 RÂ²   (0.982 RÂ² .. 1.000 RÂ²)
mean                 25.94 Î¼s   (25.72 Î¼s .. 27.12 Î¼s)
std dev              1.304 Î¼s   (239.6 ns .. 3.152 Î¼s)
variance introduced by outliers: 58% (severely inflated)

* parsing and formatting times excluded
```



Day 2
------

<!--
This section is generated and compiled by the build script at ./Build.hs from
the file `./reflections/day02.md`.  If you want to edit this, edit
that file instead!
-->

*[Prompt][d02p]* / *[Code][d02g]*

[d02p]: https://adventofcode.com/2022/day/2
[d02g]: https://github.com/egnwd/advent/blob/2022/src/AOC/Challenge/Day02.hs

Hmm... Well I messed up.

I had the solution fairly quickly by hard coding the mappings suggested and lots of lookups...
and then decided the intended solution was to find the *maximum* score given any strategy...

which does have a nice little form

```haskell
strategies = map (zip "ABC") (permutations "XYZ")
```

and then you simply need to find the maximum from applying all the strategies.


But that's wrong, so let's simplify.

First we can set up a parser, using the default lookup:

```haskell
parseGame = do
    opp <- Rock <$ "A" <|> Paper <$ "B" <|> Scissors <$ "C"
    pSpace
    you <- Rock <$ "X" <|> Paper <$ "Y" <|> Scissors <$ "Z"
    return (opp, you)
```

and then we can score a game given some rules on the winner:

```haskell
Paper    `play` Rock     = Win
Rock     `play` Scissors = Win
Scissors `play` Paper    = Win
a        `play` b
  | a == b = Draw
  | otherwise = Lose
```

I wasn't hugely happy with this, I tried an implementation with `Ord` and another with `Map`
but this was still the simplest, and it's a total function as we've parsed the inputs into nice types.

Then given the scoring functions set out in the puzzle:

```haskell
score you out = scoreRPS you + scoreOutcome out

scoreRPS = \case
    Rock     -> 1
    Paper    -> 2
    Scissors -> 3

scoreOutcome = \case
    Win  -> 6
    Draw -> 3
    Lose -> 0
```

we can score a game simply using ``\opp you -> score you (you `play` opp)``.

Finally.

Then for part two, much the same we just need a different lookup and different parser.

```haskell
parseStrategy = do
    opp <- Rock <$ "A" <|> Paper <$ "B" <|> Scissors <$ "C"
    pSpace
    out <- Lose <$ "X" <|> Draw <$ "Y" <|> Win <$ "Z"
    return (opp, out)

whatToPlay a        Draw = a
whatToPlay Paper    Win  = Scissors
whatToPlay Rock     Win  = Paper
whatToPlay Scissors Win  = Rock
whatToPlay Paper    Lose = Rock
whatToPlay Rock     Lose = Scissors
whatToPlay Scissors Lose = Paper
```

again, I'm not a fan of huge lookups but there we go.

putting together what we already have gives us ``\opp out -> score (whatToPlay opp out) out``.

Two stars, but not the most satisfying.


### Day 2 Benchmarks

```
>> Day 02a
benchmarking...
time                 5.104 ms   (5.050 ms .. 5.174 ms)
                     0.999 RÂ²   (0.998 RÂ² .. 0.999 RÂ²)
mean                 5.089 ms   (5.033 ms .. 5.130 ms)
std dev              142.0 Î¼s   (113.0 Î¼s .. 190.2 Î¼s)
variance introduced by outliers: 11% (moderately inflated)

>> Day 02b
benchmarking...
time                 2.760 ms   (2.734 ms .. 2.813 ms)
                     0.987 RÂ²   (0.962 RÂ² .. 0.999 RÂ²)
mean                 2.812 ms   (2.771 ms .. 3.004 ms)
std dev              237.1 Î¼s   (88.73 Î¼s .. 499.2 Î¼s)
variance introduced by outliers: 57% (severely inflated)
```



Day 3
------

<!--
This section is generated and compiled by the build script at ./Build.hs from
the file `./reflections/day03.md`.  If you want to edit this, edit
that file instead!
-->

*[Prompt][d03p]* / *[Code][d03g]*

[d03p]: https://adventofcode.com/2022/day/3
[d03g]: https://github.com/egnwd/advent/blob/2022/src/AOC/Challenge/Day03.hs

Interesting, today was a day where I used a different parser for part 1 and 2.

For part 1 we can split it into lines, chop each in half and turn them into sets:

```haskell
splitHalf :: String -> (Set Char, Set Char)
splitHalf s = let h = length s `div` 2
                  (l, r) splitAt h s
               in (S.fromList l, S.fromList r)

parsea :: String -> [(Set Char, Set Char)]
parsea = map splitHalf . lines
```

Then solving is a simple map and score function:

```haskell
priority :: Char -> Int
priority c
    | isUpper c = 27 + (((subtract . ord) 'A') . ord) c
    | otherwise = 1  + (((subtract . ord) 'a') . ord) c

matchingItem :: (Set Char, Set Char) -> Char
matchingItem (r1, r2) = head . S.toList $ S.intersection r1 r2

solvea = sum . map (priority . matchingItem) . parsea
```

Yay! Rucksack's organized

Part 2 was similar, but we don't need to split in half, we need batches of 3.

```haskell
parseb :: String -> [[Set Char]]
parseb = chunksOf 3 . lines
```

solving is then just repeatedly intersecting the batches:

```haskell
findGroupBadge :: [Set Char] -> Char
findGroupBadge = head . S.toList . foldl1' S.intersection

solveb = sum . map (priority . findGroupBadge) . parseb
```

One thing with the above solution (which is very close to my initial attempt)
is that it doesn't do any error handling.

What if splitting a rucksack in half leaves an empty section?
What if there is a item we don't expect, `&` perhaps?
What if we have no matching item after all the intersections?

For my final implementation I added in some error handling which was good fun,
though for these sorts of problems it's not required as the inputs are well formed.

For starters, Items can only have priorities 1-52,
so I decided to use the `Finite` type which lets you restrict the number of inhabitants of the type.

```haskell
type Item = Finite 53
```

the 53 allows for the `0` inhabitant, but you'll see why I think that's fine in a second.

Now to create the `Item` type I can use

```haskell
priority :: Char -> Maybe Item
priority c
    | isUpper c = packFinite . fromIntegral $ 27 + (((subtract . ord) 'A') . ord) c
    | otherwise = packFinite . fromIntegral $ 1  + (((subtract . ord) 'a') . ord) c
```

You'll see the type change to reflect the fact this operation can fail.
I think 53 is fine as in both branches we add at least `1` so the `0` can never appear and we can sort of sweep it under the rug.

Next I dealt with the fact intersections can leave you with an empty set.

Rucksacks can now be defined as non empty sets of characters:

```haskell
type Rucksack = NESet Char
```

Defining the intersections now needs a little more work to deal with this error case:

```haskell
intersections :: Ord a => [NESet a] -> Maybe (Set a)
intersections = foldl1May S.intersection . fmap NES.toSet
```

First, turn the non empty sets into normal sets, run the intersection using a `foldl1May`...

`foldl1May` is a left fold that assumes there is at least 1 element in the list.
Normal `foldl1` will error if you don't:

```ghci
Î»> foldl1 (+) [] :: Int
*** Exception: Prelude.foldl1: empty list
```

where as `foldl1May` returns `Nothing`:

```ghci
Î»> foldl1May (+) [] :: Maybe Int
Nothing
```

This now returns a set, as all of the elements could have been removed in the intersections.

Finally, to get out a single element from the set could be risky if they were all removed.

For this we can use `Lens`es, which has a nice function `preview` that allows you to grab the first matching element if one exists of a folded or traversable.
Here we have sets and we don't want any special filters, so plain `preview folded` should do.


For how all this is strung together check out the code, linked from the top of this reflection.


### Day 3 Benchmarks

```
>> Day 03a
benchmarking...
time                 255.3 Î¼s   (254.4 Î¼s .. 256.1 Î¼s)
                     1.000 RÂ²   (1.000 RÂ² .. 1.000 RÂ²)
mean                 254.9 Î¼s   (254.5 Î¼s .. 255.4 Î¼s)
std dev              1.572 Î¼s   (1.232 Î¼s .. 2.181 Î¼s)

* parsing and formatting times excluded

>> Day 03b
benchmarking...
time                 292.2 Î¼s   (291.6 Î¼s .. 292.9 Î¼s)
                     1.000 RÂ²   (1.000 RÂ² .. 1.000 RÂ²)
mean                 291.9 Î¼s   (291.4 Î¼s .. 292.6 Î¼s)
std dev              2.047 Î¼s   (1.555 Î¼s .. 2.879 Î¼s)

* parsing and formatting times excluded
```



Day 4
------

<!--
This section is generated and compiled by the build script at ./Build.hs from
the file `./reflections/day04.md`.  If you want to edit this, edit
that file instead!
-->

*[Prompt][d04p]* / *[Code][d04g]*

[d04p]: https://adventofcode.com/2022/day/4
[d04g]: https://github.com/egnwd/advent/blob/2022/src/AOC/Challenge/Day04.hs

Today was a nice set theory question, and for that we need to parse some sets of jobs:

```haskell
parseElfPairJobs :: String -> (ElfJobs, ElfJobs)
parseElfPairJobs s =
    let [a,b,c,d] <- map read . splitOneOf ",-" $ s
        l = IS.fromList . Ix.range $ (a,b)
        r = IS.fromList . Ix.range $ (c,d)
     in (l,r)
```

We can get a set for each of the ranges of section ids in the elves' task lists.

[Data.Ix has a really helpful function `range`](https://hackage.haskell.org/package/base-4.17.0.0/docs/Data-Ix.html#v:range) for this sort of thing.

Then for part 1 we need to see if either is a subset of the other:

```haskell
day04a = length . filter (\(l,r) -> l `isSubsetOf` r || r `isSubsetOf` l) . map parseElfPairJobs . lines
```

Yay! One star! and for part two we just need to know if there is an intersection of the two:

```haskell
day04b = length . filter (\(l,r) -> not . null . intersection l r) . map parseElfPairJobs . lines
```

with that, the ship is spick & span.


### Day 4 Benchmarks

```
>> Day 04a
benchmarking...
time                 25.35 Î¼s   (25.25 Î¼s .. 25.46 Î¼s)
                     1.000 RÂ²   (1.000 RÂ² .. 1.000 RÂ²)
mean                 25.33 Î¼s   (25.25 Î¼s .. 25.42 Î¼s)
std dev              307.2 ns   (236.3 ns .. 423.7 ns)

* parsing and formatting times excluded

>> Day 04b
benchmarking...
time                 22.30 Î¼s   (22.24 Î¼s .. 22.35 Î¼s)
                     1.000 RÂ²   (1.000 RÂ² .. 1.000 RÂ²)
mean                 22.29 Î¼s   (22.25 Î¼s .. 22.33 Î¼s)
std dev              124.7 ns   (92.67 ns .. 166.1 ns)

* parsing and formatting times excluded
```



Day 5
------

<!--
This section is generated and compiled by the build script at ./Build.hs from
the file `./reflections/day05.md`.  If you want to edit this, edit
that file instead!
-->

*[Prompt][d05p]* / *[Code][d05g]*

[d05p]: https://adventofcode.com/2022/day/5
[d05g]: https://github.com/egnwd/advent/blob/2022/src/AOC/Challenge/Day05.hs

Today was a day of tricksy parsing and simple solutions.

I'm targetting the following types to parse into:

```haskell
type Crate = Char
type Ship = IntMap [Crate]
data Instruction = Move !Int !Int !Int
```

Crates are simple `Char`s, `Ship`s are numbered columns of crates.
I'm using normal linked lists for stacks not a proper stack object as it's a small problem and actually some of the manipulations are easier.
Finally, the `Move` instructions are a simple product of number, from column and to column.

First thing we need to parse is the map of crates:

```haskell
parseCrates :: CharParser Ship
parseCrates = fromList . zip [1..] . map catMaybes . transpose <$> pRow
    where
        pRows = some (pCrate <* optional (char ' ')) `sepEndBy1` newline
        pCrate = Just <$> ("[" *> upperChar <* "]") <|> Nothing <$ "   "
```

from bottom to top we have `pCrate` which parses a `Maybe Crate`,
if there is a character in a box you get a `Just c` where `c` is the character,
and if there is no crate (`"   "`) you get `Nothing`.

`pRows` takes one or more newline seperated lines of crates that might be followed by a space (because the last isn't followed by a space).
This returns a `[[Maybe Crate]]` in a row oriented format.
We want columns and we only need the Crates that appear.

For that we transpose the `[[a]]` so that it's column oriented, keep only the `Just` values from each column.
_Note: we have to do this after the transpose to not mess up the columns._
Finally, we zip it into an IntMap using ids `1` onwards,
and thanks to Haskell being lazy we don't need to define an upper bound.

Next we parse the instructions:

```haskell
parsePlan :: CharParser [Instruction]
parsePlan = pPlan `sepEndBy1` newline
    where
        pPlan = Move <$> (labelledN "move") <*> (labelledN "from") <*> (labelledN "to")
        labelledN l = pTok l *> pTok pDecimal
```

again bottom to top, `labelledN` is a way of parsing `<label> <number> `.
A plan is parsed by `pPlan` where we take `move n `, `from f ` and `to t` and use the `Move` constructor.
Finally we take many lines of these plans returning us a `[Instruction]`.

All that is left is to put them together:

```haskell
parsePlanningSheet :: CharParser (Ship, [Instruction])
parsePlanningSheet = do
    s <- parseCrates
    skipManyTill anySingle newline <* newline
    pl <- parsePlan
    return (s, pl)
```

The middle line just skips the row of column numbers as we don't need it.


Now on to the fun bit, solving. Given we have a list of instructions and a starting state we just need a simple `foldl` over the instructions and the starting configuration of crates.

```haskell
moveCrates :: Ship -> Instruction -> Ship
moveCrates s (Move n from to)
    = adjust (moving ++) to -- add the list of crates to the to column
    . adjust (drop n) from  -- remove the crates from the from column
    $ s                     -- current ship
    where
        moving = reverse . take n $ s ! f
```

here we have a move function that will take off the `n` items (and reverse as we take off 1 by 1).

Then we just need to run each instruction and take the top element from the stacks.

```haskell
day05a = map head . foldl' moveCrates . parseOrFail parsePlanningSheet
```

Yay! A star!

For part two it's even easier! We just don't reverse the list as we grab all of them.

```haskell
moveCrates9001 :: Ship -> Instruction -> Ship
moveCrates9001 s (Move n from to)
    = adjust (moving ++) to -- add the list of crates to the to column
    . adjust (drop n) from  -- remove the crates from the from column
    $ s                     -- current ship
    where
        moving = take n $ s ! f

day05b = map head . foldl' moveCrates9001 . parseOrFail parsePlanningSheet
```

Done!


### Day 5 Benchmarks

```
>> Day 05a
benchmarking...
time                 7.637 ms   (7.534 ms .. 7.733 ms)
                     0.999 RÂ²   (0.998 RÂ² .. 0.999 RÂ²)
mean                 7.589 ms   (7.495 ms .. 7.673 ms)
std dev              254.3 Î¼s   (190.7 Î¼s .. 355.3 Î¼s)
variance introduced by outliers: 14% (moderately inflated)

>> Day 05b
benchmarking...
time                 4.078 ms   (4.055 ms .. 4.106 ms)
                     1.000 RÂ²   (0.999 RÂ² .. 1.000 RÂ²)
mean                 4.080 ms   (4.061 ms .. 4.098 ms)
std dev              52.88 Î¼s   (45.22 Î¼s .. 67.02 Î¼s)
```



Day 6
------

<!--
This section is generated and compiled by the build script at ./Build.hs from
the file `./reflections/day06.md`.  If you want to edit this, edit
that file instead!
-->

*[Prompt][d06p]* / *[Code][d06g]*

[d06p]: https://adventofcode.com/2022/day/6
[d06g]: https://github.com/egnwd/advent/blob/2022/src/AOC/Challenge/Day06.hs

My test cases hurt me today... arguably...

I got the right answer but failed some of the tests,
the rewrite cost me some time, but it is right now...

Anyway, today was a nice "one-liner" in Haskell:

After yesterday's parsing adventure today had... **none!**

so the solution for part 1 is:

```haskell
day06 =
    last                            -- Get the last index (the answer!)
    fst                             -- Get the indicies of the elements
    head                            -- Get first window satisfying the predicate
    . filter ((==4) . size . snd)   -- Filter to those windows of the correct size after deduplicating
    . map
        ( second fromList           -- Make a set out of the elements
        . unzip                     -- Make a tuple of the indicies and the elements
        . take 4)                   -- Force the windows to size 4 (the packet header size)
    . tails                         -- Make list of sliding windows
    . zip [1..]                     -- Add indicies
```

The only functions that might need some extra detail if you aren't familiar:
 - `zip`: take two lists and make a single list of pairwise elements
 - `unzip`: Take a list of tuples (`[(Int, Char)]` for example) and makea tuple of two lists `([Int], [Char])` i.e. the opposite of `zip`
 - `second`: Helper function from Bifunctor that applies a function `f` to the second element of a tuple.

Packet found!

Part 2 involves switching out (both ðŸ˜´) `4` for `14`.

Ya-ftzzz, Ove-bpzts.

Wait there is more!

The puzzle clearly says it's a datastream:

> detects a *start-of-packet marker* in the datastream

Therefore we **must** implement it using a streaming library!

Streams are made of composable pipes, here is the type [from the docs](https://mstksg.github.io/conduino/Data-Conduino.html#g:5):

For a `Pipe i o u m a`, you have:

 - `i`: Type of input stream (the things you can `await`)
 - `o`: Type of output stream (the things you `yield`)
 - `u`: Type of the result of the upstream pipe (Outputted when upstream pipe terminates)
 - `m`: Underlying monad (the things you can `lift`)
 - `a`: Result type when pipe terminates (outputted when finished, with `pure` or `return`)

So, now that you've forgotten that:

We can make our pipe for this problem:

```haskell
findPacket s
  = C.sourceList s            -- 1.
  .| C.consecutive 4          -- 2.
  .| C.map toSet              -- 3.
  .| C.filter ((== 4) . size) -- 4.
  .| await                    -- 5.
```

It looks similar to before...

1. We convert the list of signals into a stream
1. Create windows of size 4 from things flowing through the stream
1. Convert each window to a set
1. Filter them down to ones of size 4
1. Await the first element that comes through the stream

Now, unfortunately this gives us the set of unique signals, not the index...
so we need to wrap our pipe in something to track the index.

```haskell
findPacket s
  = C.sourceList s
  .| indexed
     ( C.consecutive 4
    .| C.map toSet
    .| C.filter ((== 4) . size)
    .| await)
  where
    indexed p = C.execStateP 0 (awaitForever (\x -> id += 1 >> yield x) .| p)
```

This `indexed` function awaits each elements, adds 1 to a counter and yields the awaited element.
Then finally outputs the count (i.e. how many elements it processed).

For part two again we just need to replace `4` with `14`.


### Day 6 Benchmarks

```
>> Day 06a
benchmarking...
time                 311.3 Î¼s   (302.5 Î¼s .. 318.2 Î¼s)
                     0.996 RÂ²   (0.995 RÂ² .. 0.998 RÂ²)
mean                 304.8 Î¼s   (300.9 Î¼s .. 310.0 Î¼s)
std dev              15.19 Î¼s   (11.90 Î¼s .. 17.28 Î¼s)
variance introduced by outliers: 46% (moderately inflated)

* parsing and formatting times excluded

>> Day 06b
benchmarking...
time                 2.319 ms   (2.312 ms .. 2.330 ms)
                     1.000 RÂ²   (1.000 RÂ² .. 1.000 RÂ²)
mean                 2.322 ms   (2.315 ms .. 2.329 ms)
std dev              22.40 Î¼s   (15.77 Î¼s .. 28.95 Î¼s)

* parsing and formatting times excluded
```

