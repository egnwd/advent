Reflections
===========

<!--
This file generated by the build script at ./Build.hs from the files in
./reflections.  If you want to edit this, edit those instead!
-->

Table of Contents
-----------------

* [Day 1](#day-1)
* [Day 2](#day-2)
* [Day 3](#day-3) *(no reflection yet)*
* [Day 4](#day-4)

Day 1
------

<!--
This section is generated and compiled by the build script at ./Build.hs from
the file `./reflections/day01.md`.  If you want to edit this, edit
that file instead!
-->

*[Prompt][d01p]* / *[Code][d01g]*

[d01p]: https://adventofcode.com/2021/day/1
[d01g]: https://github.com/egnwd/advent/blob/2021/src/AOC/Challenge/Day01.hs

Reading a list of ints always seems to be early on, we can do that easily with:

```haskell
parser = map read . lines
```

Then for part 1 we need to get the differences, which can be achieved by dropping the head of the
list then subtracting the two lists element-wise:

```haskell
differences x = zipWith subtract x (tail x)
```

_N.B. `subtract` is just `-` with the arguments flipped, useful for partial application._

and then to get the answer we need only the increases we just filter for where we got a postitive result:

```haskell
part1 = length . filter (>0) . differences
```

Yay! 1 star!

For part 2 we can reuse the differences logic from part 1, we just need to construct a new input list using the windows.
The easiest way to do this given the window is only length 3 is use the version of `zipWith` that takes 3 lists, this time with addition.

```haskell
summedSlidingWindows x = zipWith3 (\a b c -> a + b + c) x (drop 1 x) (drop 2 x)
```

Then to solve we just use part 1.

```haskell
part2 = part1 . summedSlidingWindows
```

Day 1 complete!


### Day 1 Benchmarks

```
>> Day 01a
benchmarking...
time                 47.27 Î¼s   (46.45 Î¼s .. 48.43 Î¼s)
                     0.994 RÂ²   (0.990 RÂ² .. 0.997 RÂ²)
mean                 47.09 Î¼s   (45.79 Î¼s .. 48.64 Î¼s)
std dev              4.412 Î¼s   (3.534 Î¼s .. 5.703 Î¼s)
variance introduced by outliers: 82% (severely inflated)

* parsing and formatting times excluded

>> Day 01b
benchmarking...
time                 208.5 Î¼s   (202.4 Î¼s .. 214.6 Î¼s)
                     0.994 RÂ²   (0.990 RÂ² .. 0.997 RÂ²)
mean                 210.7 Î¼s   (206.9 Î¼s .. 216.4 Î¼s)
std dev              15.33 Î¼s   (10.99 Î¼s .. 20.72 Î¼s)
variance introduced by outliers: 67% (severely inflated)

* parsing and formatting times excluded
```



Day 2
------

<!--
This section is generated and compiled by the build script at ./Build.hs from
the file `./reflections/day02.md`.  If you want to edit this, edit
that file instead!
-->

*[Prompt][d02p]* / *[Code][d02g]*

[d02p]: https://adventofcode.com/2021/day/2
[d02g]: https://github.com/egnwd/advent/blob/2021/src/AOC/Challenge/Day02.hs

Moving around a 2D map, another AoC classic challenge.

My initial solution used recursion and word splitting for the solution,
the second used State, and that too was more difficult to understand, and felt more imperative.

The version here uses Monoids to combine the values (part a ended up similar to my first fold attempt).

To parse we can read many `Sum`mable `Points` and have that as our instruction set.
The parser combinators make this quite nice to do:

```haskell
parser = do
  dir <- pTok $
        (Sum . flip V2 0     <$ "forward")
    <|> (Sum . V2 0 . negate <$ "up")
    <|> (Sum . V2 0          <$ "down")
  dir <$> pDecimal
```

Then to solve part 1 we just need to combine the instructions.
I used the `V2` type from `Linear.V2` to represent points as they are 2D vectors with the added bonus of
being able to easily to component-wise addition of vectors.

```haskell
solve = product . getSum . mconcat
```

After the submarine's epic journey, we get 1 star!

For part two, I wrote a new type `Submarine` with a location and aim.

```haskell
data Submarine = Sub { loc :: Point, aim :: Int }
```

this time to combine we must implement `Monoid`, and first Semigroup.

```haskell
instance Semigroup Submarine where
    (Sub v a) <> (Sub (V2 x' y') a') = Sub (v + V2 x' (y' + x' * a)) (a + a')

instance Monoid Submarine where
    mempty = Sub (pure 0) 0
    mconcat = foldl (<>) mempty
```

`(<>)` combines two commands, adding the forward components `x+x'`,
updates the depth taking into account the previous aim and the forward distance
`y + y' + x' * a` (for the `up` & `down` commands `x'` & `y'` are `0` so that term cancels),
and finally the aim is updated (for `forward` this is `0` so is also a noop).

Then to combine we do similar to part 1:
```haskell
solve = product . loc . mconcat
```

where `loc` gets the vector from the `Submarine` akin to `getSum` getting the vector from `Sum`.

Submarine successfully piloted!


### Day 2 Benchmarks

```
>> Day 02a
benchmarking...
time                 3.811 ms   (3.759 ms .. 3.889 ms)
                     0.997 RÂ²   (0.995 RÂ² .. 0.999 RÂ²)
mean                 3.781 ms   (3.721 ms .. 3.821 ms)
std dev              164.2 Î¼s   (126.4 Î¼s .. 240.8 Î¼s)
variance introduced by outliers: 25% (moderately inflated)

>> Day 02b
benchmarking...
time                 2.332 ms   (2.310 ms .. 2.357 ms)
                     0.999 RÂ²   (0.999 RÂ² .. 1.000 RÂ²)
mean                 2.345 ms   (2.330 ms .. 2.363 ms)
std dev              54.61 Î¼s   (42.35 Î¼s .. 69.57 Î¼s)
variance introduced by outliers: 10% (moderately inflated)
```



Day 3
------

<!--
This section is generated and compiled by the build script at ./Build.hs from
the file `./reflections/day03.md`.  If you want to edit this, edit
that file instead!
-->

*[Prompt][d03p]* / *[Code][d03g]*

[d03p]: https://adventofcode.com/2021/day/3
[d03g]: https://github.com/egnwd/advent/blob/2021/src/AOC/Challenge/Day03.hs

*Reflection not yet written -- please check back later!*

### Day 3 Benchmarks

```
>> Day 03a
benchmarking...
time                 2.608 ms   (2.560 ms .. 2.668 ms)
                     0.997 RÂ²   (0.996 RÂ² .. 0.998 RÂ²)
mean                 2.565 ms   (2.531 ms .. 2.593 ms)
std dev              111.2 Î¼s   (82.98 Î¼s .. 138.1 Î¼s)
variance introduced by outliers: 28% (moderately inflated)

* parsing and formatting times excluded

>> Day 03b
benchmarking...
time                 502.3 Î¼s   (499.8 Î¼s .. 505.3 Î¼s)
                     1.000 RÂ²   (1.000 RÂ² .. 1.000 RÂ²)
mean                 508.0 Î¼s   (505.6 Î¼s .. 511.4 Î¼s)
std dev              10.85 Î¼s   (7.919 Î¼s .. 18.69 Î¼s)
variance introduced by outliers: 12% (moderately inflated)

* parsing and formatting times excluded
```



Day 4
------

<!--
This section is generated and compiled by the build script at ./Build.hs from
the file `./reflections/day04.md`.  If you want to edit this, edit
that file instead!
-->

*[Prompt][d04p]* / *[Code][d04g]*

[d04p]: https://adventofcode.com/2021/day/4
[d04g]: https://github.com/egnwd/advent/blob/2021/src/AOC/Challenge/Day04.hs

Bingo against a giant squid is a funny idea ðŸ˜†

Today we got to learn about two Semigroups! `First` and `Last`,
they are fairly self explanatory, `First` will give you the left (first) argument to `(<>)`
and `Last` will give you the second (last) argument to `(<>)`.

_N.B. `Last` is the `Dual` of `First`._

To parse we need two things, the list of numbers and all the cards.

```haskell
data BingoNumber = Unmarked Int | Marked Int deriving (Eq, Show)
type BingoCard = [[BingoNumber]]

parse :: String -> ([Int], [BingoCard])
```

Here we can represent a number as either marked or unmarked (note this is just `Either` with a nicer name).

Then we can define our solve function to take the list of numbers, the boards, and return the score, maybe.

```haskell
solve :: [Int] -> [BingoCard] -> Maybe Score
```

(We will look at `Score` later.)

Then as we see a number, `n`, we mark all our cards.

```haskell
newCards n cards = cards'
  where
    cards' = cards <&> mapped.mapped %~ mark
    mark (Unmarked x) | x == n = Marked x
    mark x = x
```

We can define what it means for a card to have won:

```haskell
winner :: BingoCard -> Bool
winner cards = row cards || column cards
    where
        column = row . transpose
        row = any (all isMarked)

isMarked :: BingoNumber -> Bool
isMarked = \case
    Marked _ -> True
    _ -> False
```

Next, we work out the scores for all the winners this round.

```haskell
scoreWinners cards' n = winners
  where
      winners = foldMap (Just . First . scoreCard) w
      w = filter winner cards'
      scoreCard card = (sum . unmarked $ card) * n
      unmarked = map unmarkedValue . concat

unmarkedValue :: BingoNumber -> Int
unmarkedValue (Unmarked n) = n
unmarkedValue (Marked _)   = 0
```

and here is where we get to see `First`.

We've taken our cards and found the winners, then we score them using the score system from the problem statement,
and next we make a `Maybe (First Int)` with `Just . First`. This represents (the maybe is to represent the fact we have a score).

`foldMap` will the return `Nothing` if there are no winners this round, or `Just (First x)` where `x` is the score of the first winner.

We then recurse on the rest of the numbers and the boards that haven't won yet.

```haskell
solve (n:ns) cards = scoreWinners cards' n <> solve ns (filter (not . winner) cards')
  where
    cards' = newCards n cards
```

Now for part two all we need to do is swap `First` for `Last`!!

Now, hopefully the squid doesn't eat us.


### Day 4 Benchmarks

```
>> Day 04a
benchmarking...
time                 15.18 ms   (14.92 ms .. 15.40 ms)
                     0.998 RÂ²   (0.997 RÂ² .. 0.999 RÂ²)
mean                 15.10 ms   (14.94 ms .. 15.24 ms)
std dev              380.8 Î¼s   (270.1 Î¼s .. 579.1 Î¼s)

* parsing and formatting times excluded

>> Day 04b
benchmarking...
time                 20.12 ms   (19.95 ms .. 20.35 ms)
                     1.000 RÂ²   (0.999 RÂ² .. 1.000 RÂ²)
mean                 20.05 ms   (19.94 ms .. 20.14 ms)
std dev              231.6 Î¼s   (169.9 Î¼s .. 321.9 Î¼s)

* parsing and formatting times excluded
```

